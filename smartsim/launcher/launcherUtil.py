import os
from subprocess import Popen, PIPE
from datetime import datetime

class LauncherException(Exception):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)

class LauncherArgException(LauncherException):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)

class LauncherBadOpException(LauncherException):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)

class OperationNotImplementedException(LauncherException):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)

class ScriptInfo:
	"""
	A simple class to contain the information about the script
	The name, location, err and output file names
	"""
	def __init__(self, sc_name="", sc_path="", err_full="", output_full=""):
		"""
		sc_name the name of the script
		sc_path: the path to the directory containing the script
		err_full: complete absolute path to the error file
		output_full: complete absolute path to the output file
		"""
		self.sc_name=sc_name
		self.sc_path=sc_path
		self.err_full=err_full
		self.output_full = output_full
		self.initialized = False
		self.extention = ""

	def clear_sc_info(self):
		self.clear_sc_location()
		self.err_full = self.output_full = ""

	def clear_sc_location(self):
		self.sc_name = self.sc_path = ""
		self.extention = ""

	def set_sc_name(self,name):
		dot_loc = name.rfind(".")
		#the name .filename is valid but filename is not an extention
		if dot_loc > 0:
			self.sc_name = name[:dot_loc]
			self.extention = name[dot_loc:]
		else:
			self.sc_name = name
			self.extention = ""

	def get_sc_full_path(self):
		return os.path.join(self.sc_path, self.sc_name) + self.extention


	def set_script_info(self, full_path):
		"""
		taking the full path to a file, uses it as a script and sets the name and path to it
		"""
		name_tuple = os.path.split(full_path)
		self.sc_path = name_tuple[0]
		#looking for the extention location
		tail = name_tuple[1]
		self.set_sc_name(tail)

def seq_to_str(seq, to_byte=False, encoding="utf-8", add_equal=False):
	"""
	An auxiliary function to convert the commands in the sequence format to string format
	This is necessary based on the shell boolean used when we start a subprocess. the problem
	is the --option=value. Otherwise, a simple " ".join would suffice
	:param seq (string array)
	:param to_byte(bool) whether or not convert to byte stream
	"""
	cmd_str = ""
	#if we do not translate --option,arg to --option=arg we only need to join with spaces
	if not add_equal:
		return " ".join(seq)

	for cmd in seq:
		# handling the slurm style of --option=argument format
		#@todo not nice! improve
		if cmd.startswith("--") and cmd != "--no-shell":
				cmd_str += cmd + "="
		else:
				cmd_str += cmd+ " "
	if to_byte:
		return cmd_str.encode(encoding)
	else:
		return cmd_str


def extract_line(output, key):
	"""
	an auxiliary function to find a key in a multi-line string
	:returns the first line which contains the key
	"""
	for line in output:
		if key in line:
			return line
	return None


def current_time_military(minute_add = 0):
	"""
	returns the current time in format hhmm as a string
	"""
	t_now = datetime.now()
	hour_int = t_now.hour
	minute_int = t_now.minute
	new_mins = minute_int + minute_add
	minute_int = new_mins % 60
	hour_int += new_mins // 60


	if hour_int < 10:
		hour_str = "0%d" % hour_int
	else:
		hour_str = str(hour_int)
	if minute_int < 10:
		minute_str = "0%d" % minute_int
	else:
		minute_str = str(minute_int)
	return hour_str + minute_str


def get_output_err(sc_info, out_err_tuple=None):
	"""
	takes either a ScriptInfo instance or a tuple denoting the path to output and error files
	generated by the script and returns the output,error
	:param sc_info (Script_Info)
	:param out_err_tuple tuple(string) (path to output file, path to error file)
	reads the output and error file generated by submiting a script
	returns a tuple (output, err)
	"""
	if sc_info is None:
		if not isinstance(out_err_tuple, tuple):
			raise LauncherArgException("The path to the files should be given either through sc_info or a tuple")    
		out_file = out_err_tuple[0]
		err_file = out_err_tuple[1]
	else:
		if sc_info.err_full is None or sc_info.output_full is None:
			raise LauncherArgException("The path to error and output are not set")
		out_file = sc_info.output_full
		err_file = sc_info.err_full
	with open (out_file,'r') as out_stream:
		output = out_stream.read()

	with open(err_file,'r') as err_stream:
		err = err_stream.read()

	return (output, err)

def prepend_cd(wd, cmd):
	"""
	used for prepending "cd dir" to the list of commands that goes into a script
	:param dir (str) the directory to cd into before listing the rest of the
		commands in the script
	:param command list(str) the list of the commands to which cd dir is being prepended
	"""
	#to avoid repeating this over and over I turned it into a function
	#insert(0, str) is more efficient than using + but still O(n)
	wd = wd.strip()
	if wd:
		cmd.insert(0, "cd %s" % wd)
